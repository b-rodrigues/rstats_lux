---
date: 2017-10-21T06:34:55+02:00
title: "Scraping data from the local elections"
author: "Kevin Rosamont"
banner : "images/results.svg"
categories: ["R"]
tags: ["Scrapping"]
description : "Web scraping consists in extracting data from websites. Here we will scrape results from the Luxembourg local elections 2017."
weight : 1
---



<p>One of my journalist friend was looking at the result of the local election in Luxembourg and he was dissatisfied because he was unable to compare the results of all the communes. In fact, he wanted to compare the number of women that were candidates in each commune. So I asked him to hold on and I came back one hour later with this script that enables him to collect results of all communes in one table.</p>
<p>At the beginning, it was a private code but I thought that it could be another great scraping example after the excellent post written by my colleague Bruno Rodrigues about scraping data from STATEC public tables.</p>
<p>So let’s get started with the loading packages.</p>
<pre class="r"><code>#we have to load the packages if they are not installed on your computer,
#begin with the commented following lines:
#install.packages( &quot;rvest&quot; )
#install.packages( &quot;tidyverse&quot; )
#install.packages( &quot;stringr&quot; )

library(rvest) #to scrap</code></pre>
<pre><code>## Warning: package &#39;rvest&#39; was built under R version 3.2.5</code></pre>
<pre><code>## Loading required package: xml2</code></pre>
<pre><code>## Warning: package &#39;xml2&#39; was built under R version 3.2.5</code></pre>
<pre class="r"><code>library(dplyr) #to manipulate data</code></pre>
<pre><code>## Warning: package &#39;dplyr&#39; was built under R version 3.2.5</code></pre>
<pre><code>## 
## Attaching package: &#39;dplyr&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:stats&#39;:
## 
##     filter, lag</code></pre>
<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     intersect, setdiff, setequal, union</code></pre>
<pre class="r"><code>library(stringr) #to manipulate string</code></pre>
<pre><code>## Warning: package &#39;stringr&#39; was built under R version 3.2.5</code></pre>
<p>We want to collect results of all communes in one data frame. We go to <a href="http://www.elections.public.lu" class="uri">http://www.elections.public.lu</a> and we collect data that is seen in the GIF bellow:</p>
<p>After clicking on different communes, we notice that the URL have the same format. They have 3 parts :<br> 1: “<a href="http://www.elections.public.lu/fr/elections-communales/2017/resultats/communes/" class="uri">http://www.elections.public.lu/fr/elections-communales/2017/resultats/communes/</a>”, the first part of the URL.<br> 2: “communes_names” the name of the city is the second part of the URL.<br> 3: “.html” is the last part.<br></p>
<p>For example, the complete URL for the commune of Luxembourg will be: <a href="http://www.elections.public.lu/fr/elections-communales/2017/resultats/communes/luxembourg.html" class="uri">http://www.elections.public.lu/fr/elections-communales/2017/resultats/communes/luxembourg.html</a><br><br></p>
<p>There are 103 communes, so we have to put all of them in a list of vector. We scrape the 103 communes in one vector via the script bellow :</p>
<pre class="r"><code>url = &quot;http://www.elections.public.lu/fr/elections-communales/2017/resultats/communes/bech.html&quot;
communes = read_html(url) %&gt;% 
        html_nodes(&quot;#communes #communes-az li&quot;) %&gt;%
        html_text() </code></pre>
<p>We verify that we have a list of 103 vectors and then we check the 5 first rows.</p>
<pre class="r"><code>length(communes)</code></pre>
<pre><code>## [1] 103</code></pre>
<pre class="r"><code>head(communes,5)</code></pre>
<pre><code>## [1] &quot;\r\n        Beaufort\r\n                a rendu l&#39;ensemble de ses résultats\r\n    &quot; 
## [2] &quot;\r\n        Bech\r\n                a rendu l&#39;ensemble de ses résultats\r\n    &quot;     
## [3] &quot;\r\n        Beckerich\r\n                a rendu l&#39;ensemble de ses résultats\r\n    &quot;
## [4] &quot;\r\n        Berdorf\r\n                a rendu l&#39;ensemble de ses résultats\r\n    &quot;  
## [5] &quot;\r\n        Bertrange\r\n                a rendu l&#39;ensemble de ses résultats\r\n    &quot;</code></pre>
<p>It seems that the 103 communes are present but we still have to clean the data.</p>
<pre class="r"><code>#Data is not cleaned and there are some useless characters that need to be removed.
#We need to clean data.
communes = gsub(&quot;a rendu l&#39;ensemble de ses résultats&quot;,&quot; &quot;, communes )
communes = trimws(gsub(&quot;\r\n&quot;,&quot;&quot;,communes ))
communes = gsub(&quot;/Attert&quot;,&quot;-sur-attert&quot;, communes )
communes = gsub(&quot; - &quot;, &quot;-&quot;,communes )
communes = gsub(&quot; &quot;, &quot;-&quot;,communes )
communes = gsub(&quot;&#39;&quot;, &quot;-&quot;,communes )
communes = gsub(&quot;é&quot;, &quot;e&quot;,communes )
communes = gsub(&quot;û&quot;, &quot;u&quot;,communes )
communes = gsub(&quot;ä&quot;, &quot;a&quot;,communes )

#Lower case
communes = tolower(communes)

head(communes, 5)</code></pre>
<pre><code>## [1] &quot;beaufort&quot;  &quot;bech&quot;      &quot;beckerich&quot; &quot;berdorf&quot;   &quot;bertrange&quot;</code></pre>
<p>Now that we have the list of the 103 communes, we will write a function that will enable us to collect data that we want to display in our data frame.</p>
<pre class="r"><code>#Function to have the result for one commune.
result= function(x){
#scrapping data
vote = read_html(paste(&quot;http://www.elections.public.lu/fr/elections-communales/2017/resultats/communes/&quot;,x,&quot;.html&quot;, sep=&quot;&quot;)) %&gt;% 
        html_nodes(&quot;#lux-number .lux-number ul li&quot;) %&gt;%
        html_text()%&gt;%.[-1]

#Conditions need to be added to have clean data.
#Here we add a trick, the vector 14 and 15 are the only ones that haven&#39;t the string &quot;\r\n&quot;.
#So we add &quot;\r\n&quot; to these vectors.
if(nchar(vote[14])&gt;21){
        vote[14] =gsub (&quot;ble&quot;,&quot;ble\r\n&quot;, vote[14],perl = FALSE)
}
if(nchar(vote[15])&gt;21){
        vote[15] =gsub (&quot;mé&quot;,&quot;mé\r\n&quot;, vote[15],perl = FALSE)
}
#We split vectors to dissociate the results (numbers) and the titles (letters).
vote = unlist(str_split(vote, &quot;\r\n&quot;))
vote = trimws(vote)
vote = vote[vote!=&quot;&quot;]

#Here we have similar title so we change them to not be confused.
#Candidat Lux means Luxemburgish Candidates  &amp; Electeur Lux means Luxemburgish voters. 
vote[7] = gsub(&quot;Lux&quot;, &quot;Candidat Lux&quot;, vote[7] )
vote[9] = gsub(&quot;Non Lu&quot;, &quot;Candidat Non Lu&quot;, vote[9] )
vote[13] = gsub(&quot;Lux&quot;, &quot;Electeur Lux&quot;, vote[13] )
vote[15] = gsub(&quot;Non Lu&quot;, &quot;Electeur Non Lu&quot;, vote[15]  )

#We create the data frame.
#Vector with pair indice value are the results (the column val).
pair = (1:15)*2

#Vector with impair indice value are the titles (the column title).
impair = (1:15)*2-1
res = data.frame(communes = rep(x,15), title = vote[impair], val = vote[pair])
return(res)
}</code></pre>
<p>Then we use the lapply() function to apply this function to the 103 communes and bind them in one data frame.</p>
<pre class="r"><code>#We use the result function on all the communes.
res = lapply(communes, result)
#We bind the rows to have a complete data frame with all the results from all communes
#then we bind all the result.
df = do.call(rbind, res)</code></pre>
<p>To see the 5 first rows of our new data frame:</p>
<pre class="r"><code>#Now the data that we have look like this:
head(df,5)</code></pre>
<pre><code>##   communes                       title val
## 1 beaufort                       Total  10
## 2 beaufort                      Femmes   5
## 3 beaufort                      Hommes   5
## 4 beaufort     Candidat Luxembourgeois  10
## 5 beaufort Candidat Non Luxembourgeois   0</code></pre>
<p>As you can see, it’s looking good but we are not completely satisfied because we would like to transpose data to have one result in one column. To this end, we use the library(tidyr).</p>
<pre class="r"><code>library(tidyr)</code></pre>
<pre><code>## Warning: package &#39;tidyr&#39; was built under R version 3.2.5</code></pre>
<pre class="r"><code>#Transposing data will enables us to make analysis faster.
#We transform val in a numeric variable than we transpose data.

tdf = df %&gt;%
        mutate(val=as.numeric(gsub(&quot; &quot;, &quot;&quot;, val))) %&gt;%
        spread(title, val)</code></pre>
<pre><code>## Warning: package &#39;bindrcpp&#39; was built under R version 3.2.5</code></pre>
<p>To see the 5 first rows of our new data frame:</p>
<pre class="r"><code>#Now the data that we have look like this:
head(tdf,5)</code></pre>
<pre><code>##    communes Blancs Candidat Luxembourgeois Candidat Non Luxembourgeois
## 1  beaufort     78                      10                           0
## 2      bech      0                       8                           0
## 3 beckerich     67                      10                           1
## 4   berdorf     23                      20                           0
## 5 bertrange     75                      45                           7
##   Dans l&#39;urne Electeur Luxembourgeois Electeur Non Luxembourgeois Femmes
## 1        1144                    1170                         114      5
## 2           0                     699                          95      1
## 3        1396                    1393                         137      2
## 4         857                     850                          79      7
## 5        2935                    2972                         478     22
##   Grand total exprimé Grand total possible Hommes Inscrits Nuls Total
## 1                4021                 9234      5     1284   40    10
## 2                   0                    0      7      794    0     8
## 3                5792                11637      9     1530   36    11
## 4                4929                 7371     13      929   15    20
## 5               32880                35620     30     3450  120    52
##   Valables Votes par correspondance
## 1     1026                       71
## 2        0                        0
## 3     1293                      109
## 4      819                       57
## 5     2740                      269</code></pre>
<p>Now you can export the table in excel or play with your data in R!</p>
<pre class="r"><code>readr::write_excel_csv(tdf,&quot;election_lux.csv&quot;)
#To know where your file is saved, we use the following function:
#setwd()</code></pre>
<p>I hope you enjoyed reading this post. Don’t hesitate to contact us for any questions. Follow us on <a href="https://twitter.com/rdata_lu?lang=en">twitter</a> and subscribe to our <a href="https://www.youtube.com/channel/UCbazvBnJd7CJ4WnTL6BI6qw">youtube channel.</a> See you for the next post ;) <br></p>
<p>Kevin</p>
